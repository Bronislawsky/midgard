#!/usr/bin/env bash
# file : ./scripts/pull-sql
#------------------------------------------------------------------------------
#
#         .__    .___                      .___
#   _____ |__| __| _/ _________ _______  __| _/
#  /     \|  |/ __ | / ___\__  \\_  __ \/ __ |
# |  Y Y  \  / /_/ |/ /_/  > __ \|  | \/ /_/ |
# |__|_|  /__\____ |\___  (____  /__|  \____ |
#       \/        \/_____/     \/           \/
#
# pull-sql â€” dump remote MySQL/MariaDB and save locally
#------------------------------------------------------------------------------

[[ "${MIDGARD_MAIN:-}" == "1" ]] || { echo "Must be sourced by midgard"; return 1 2>/dev/null || exit 1; }

_get() {
  local __arr_name="$1" __key="$2"
  eval "printf '%s' \"\${$__arr_name[\"$__key\"]-}\""
}

# kept for compatibility (no longer needed in this flow)
_sq() { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

pull_sql_site() {
  local site="${1:-}"; [[ -n "$site" ]] || { echo "pull_sql_site: missing site"; return 1; }
  local arr="${CONFIG_SITES[$site]:-}"; [[ -n "$arr" ]] || { echo "pull_sql_site: site not loaded: $site"; return 1; }

  # inputs
  local REMOTE_USER REMOTE_HOST SSH_KEY_PRIV LOCAL_SYNC_PATH LOCAL_SQL_PATH LOCAL_SQL_FILE
  local DB_USER DB_PASS DB_HOST DB_NAME
  REMOTE_USER="$(_get "$arr" REMOTE_USER)"
  REMOTE_HOST="$(_get "$arr" REMOTE_HOST)"
  SSH_KEY_PRIV="$(_get "$arr" SSH_KEY_PRIV)"
  LOCAL_SYNC_PATH="$(_get "$arr" LOCAL_SYNC_PATH)"
  LOCAL_SQL_PATH="$(_get "$arr" LOCAL_SQL_PATH)"
  LOCAL_SQL_FILE="$(_get "$arr" LOCAL_SQL_FILE)"
  DB_USER="$(_get "$arr" DB_USER)"
  DB_PASS="$(_get "$arr" DB_PASS)"
  DB_HOST="$(_get "$arr" DB_HOST)"
  DB_NAME="$(_get "$arr" DB_NAME)"

  # log/report
  local log_dir="logs/${EPOCH_TIMESTAMP}"
  local rep_dir="reports/${EPOCH_TIMESTAMP}"
  local site_log="${log_dir}/${site}.log"
  local site_rep="${rep_dir}/${site}.report"
  mkdir -p "$log_dir" "$rep_dir"

  # local dump path
  local local_sql_dir="${LOCAL_SYNC_PATH%/}${LOCAL_SQL_PATH}"
  mkdir -p "$local_sql_dir"
  local dest_tmp="${local_sql_dir%/}/${LOCAL_SQL_FILE}.tmp"
  local dest_sql="${local_sql_dir%/}/${LOCAL_SQL_FILE}"

  # sanity
  local errs=()
  [[ -n "$REMOTE_USER" ]] || errs+=("REMOTE_USER missing")
  [[ -n "$REMOTE_HOST" ]] || errs+=("REMOTE_HOST missing")
  [[ -n "$SSH_KEY_PRIV" && -r "$SSH_KEY_PRIV" ]] || errs+=("SSH private key not readable: $SSH_KEY_PRIV")
  [[ -n "$DB_USER" ]] || errs+=("DB_USER missing")
  [[ -n "$DB_PASS" ]] || errs+=("DB_PASS missing")
  [[ -n "$DB_HOST" ]] || errs+=("DB_HOST missing")
  [[ -n "$DB_NAME" ]] || errs+=("DB_NAME missing")
  if ((${#errs[@]})); then
    status_fail
    printf '    - %s\n' "${errs[@]}"
    echo "SQL=FAIL" >>"$site_rep"
    return 1
  fi

  status_start "Dumping database for ${site} ..."
  echo

  # ssh/scp opts
  local SSH_OPTS=(-i "$SSH_KEY_PRIV" -o BatchMode=yes -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15)
  local SCP_OPTS=(-i "$SSH_KEY_PRIV" -o BatchMode=yes -o StrictHostKeyChecking=accept-new -o ConnectTimeout=15 -q)

  # 1) ensure remote tmp dir
  local remote_tmp_dir
  if ! remote_tmp_dir="$(
    ssh -T "${SSH_OPTS[@]}" "${REMOTE_USER}@${REMOTE_HOST}" \
      'mkdir -p "$HOME/.tmp-backup" && chmod 700 "$HOME/.tmp-backup" && printf "%s" "$HOME/.tmp-backup"' \
      </dev/null 2>>"$site_log"
  )"; then
    status_fail
    echo "    - cannot create/access remote tmp dir (~/.tmp-backup)" | tee -a "$site_log"
    echo "SQL=FAIL" >> "$site_rep"
    return 1
  fi

  # 2) create local temp .my.cnf and upload securely
  umask 077
  local local_mycnf; local_mycnf="$(mktemp "/tmp/.my.cnf-${site}.XXXXXX")" || {
    status_fail; echo "    - mktemp failed locally" | tee -a "$site_log"; echo "SQL=FAIL" >> "$site_rep"; return 1; }
  {
    printf "[client]\n"
    printf "user=%s\n"     "%s" "$DB_USER"
    printf "password=%s\n" "%s" "$DB_PASS"
    printf "host=%s\n"     "%s" "$DB_HOST"
  } 1> "$local_mycnf"

  chmod 600 "$local_mycnf" 2>>"$site_log" || true

  local ts; ts="$(date +%Y%m%d-%H%M%S)"
  local remote_mycnf="${remote_tmp_dir}/.my.cnf-${ts}-$$"

  if ! scp "${SCP_OPTS[@]}" -- "$local_mycnf" "${REMOTE_USER}@${REMOTE_HOST}:${remote_mycnf}" 2>>"$site_log"; then
    rm -f "$local_mycnf"
    status_fail
    echo "    - failed to upload remote .my.cnf" | tee -a "$site_log"
    echo "SQL=FAIL" >> "$site_rep"
    return 1
  fi
  rm -f "$local_mycnf" 2>/dev/null || true

  # 3) run mysqldump on remote using --defaults-extra-file, stream to local tmp
  #    nothing sensitive in argv beyond the path to the temp file
  if ssh -T "${SSH_OPTS[@]}" "${REMOTE_USER}@${REMOTE_HOST}" \
       "MD=\$(command -v mysqldump || true); : \${MD:=mysqldump}; \"\$MD\" --defaults-extra-file=$(printf %q "$remote_mycnf") --single-transaction --default-character-set=utf8mb4 --skip-lock-tables $(printf %q "$DB_NAME")" \
        | tee "$dest_tmp" >/dev/null 2>>"$site_log"
  then
    mv -f "$dest_tmp" "$dest_sql"
    chmod 640 "$dest_sql"
    echo "  SQL dump saved to: $dest_sql" | tee -a "$site_log"
    status_ok
    echo "SQL=OK" >> "$site_rep"
    # 4) cleanup remote temp file (leave dir for reuse)
    ssh -T "${SSH_OPTS[@]}" "${REMOTE_USER}@${REMOTE_HOST}" "rm -f -- $(printf %q "$remote_mycnf")" </dev/null 2>>"$site_log" || true
    return 0
  else
    rc=$?
    status_fail
    echo "    - mysqldump via SSH failed for ${site} (rc=$rc)" | tee -a "$site_log"
    [[ -f "$dest_tmp" ]] && rm -f "$dest_tmp"
    echo "SQL=FAIL" >> "$site_rep"
    # attempt cleanup even on failure
    ssh -T "${SSH_OPTS[@]}" "${REMOTE_USER}@${REMOTE_HOST}" "rm -f -- $(printf %q "$remote_mycnf")" </dev/null 2>>"$site_log" || true
    return 1
  fi
}

#!/usr/bin/env bash
# file : ./scripts/scan-wordfence-vuln
#------------------------------------------------------------------------------
#
#         .__    .___                      .___
#   _____ |__| __| _/ _________ _______  __| _/
#  /     \|  |/ __ | / ___\__  \\_  __ \/ __ |
# |  Y Y  \  / /_/ |/ /_/  > __ \|  | \/ /_/ |
# |__|_|  /__\____ |\___  (____  /__|  \____ |
#       \/        \/_____/     \/           \/
#
# scan-wordfence-vuln — Wordfence CLI vuln scan against a site's WP root
#   - must be sourced by ./midgard (MIDGARD_MAIN=1)
#   - uses CONFIG_SITES + EPOCH_TIMESTAMP + status_* helpers
#   - logs to   ./logs/$EPOCH_TIMESTAMP/<site>.log
#   - any vulnerability found => FAIL (human review required)
#------------------------------------------------------------------------------
[[ "${MIDGARD_MAIN:-}" == "1" ]] || {
  echo "This script must be sourced from the midgard launcher." >&2
  return 1 2>/dev/null || exit 1
}

scan_wordfence_vuln_main() {

  local site="$1"

  mkdir -p "${MIDGARD_SESSION_LOG_DIR}" "${MIDGARD_SESSION_REPORT_DIR}"
  local SITE_LOG_FILE="${MIDGARD_SESSION_LOG_DIR}/${site}.log"
  local SITE_REPORT_FILE="${MIDGARD_SESSION_REPORT_DIR}/${site}.report"

  if [[ -z "$site" ]]; then
    echo "scan_wordfence_vuln_main: missing site" >&2
    echo "$(midgard_current_time) Wordfence-CLI vulnerability Scan [FAILED]" >> "$SITE_LOG_FILE"
    echo "WORDFENCE_VULN=FAIL" >> "$SITE_REPORT_FILE"
    return 1
  fi

  local assoc_name="${CONFIG_SITES[$site]:-}"
  if [[ -z "$assoc_name" ]]; then
    echo "scan_wordfence_vuln_main: site not loaded: $site" >&2
    echo "$(midgard_current_time) Wordfence-CLI vulnerability Scan" >> "$SITE_LOG_FILE"
    echo "WORDFENCE_VULN=FAIL" >> "$SITE_REPORT_FILE"
    return 1
  fi

  # Per-site toggles & values (from sites-data / .conf already loaded)
  local LOCAL_SYNC_PATH LOCAL_DOCUMENT_ROOT LOCAL_WP_ROOT
  local WORDFENCE_VULN_ENABLE

  WORDFENCE_VULN_ENABLE="$(midgard_get_value_from_array "$assoc_name" WORDFENCE_VULN_ENABLE)"

  if [[ "$WORDFENCE_VULN_ENABLE" != "y" ]]; then
    echo -e "$(midgard_current_time) ${site} Wordfence-CLI vulnerability Scan ${c_light_blue}[${c_light_red}DISABLED${c_light_blue}]${c_reset}"
    echo "$(midgard_current_time) Wordfence-CLI vulnerability Scan [DISABLED]" >> "${SITE_LOG_FILE}"
    echo "WORDFENCE_VULN=SKIPPED" >> "${SITE_REPORT_FILE}"
    return 0
  fi

  echo -e "$(midgard_current_time) ${site} Wordfence-CLI vulnerability Scan ${c_light_blue}[${c_green}STARTED${c_light_blue}]${c_reset}"
  echo "$(midgard_current_time) Wordfence-CLI Database Scan [STARTED]" >> "$SITE_LOG_FILE"

  LOCAL_SYNC_PATH="$(midgard_get_value_from_array "$assoc_name" LOCAL_SYNC_PATH)"
  LOCAL_DOCUMENT_ROOT="$(midgard_get_value_from_array "$assoc_name" LOCAL_DOCUMENT_ROOT)"
  LOCAL_WP_ROOT="${LOCAL_SYNC_PATH%/}${LOCAL_DOCUMENT_ROOT}"

  # sanity + env
  local errors=()
  [[ -n "$LOCAL_SYNC_PATH" ]] || errors+=("LOCAL_SYNC_PATH")
  [[ -n "$LOCAL_DOCUMENT_ROOT"  ]] || errors+=("LOCAL_DOCUMENT_ROOT")
  [[ -n "$LOCAL_WP_ROOT"  ]] || errors+=("LOCAL_WP_ROOT")
  [[ -x "$WORDFENCE_BIN" ]] || errors+=("WORDFENCE_BIN")

  if (( ${#errors[@]} )); then
    for err in "${errors[@]}"; do
      echo -e "$(midgard_current_time) ${site}   Please verify ${c_light_red}${err}${c_reset}"
    done
    echo -e "$(midgard_current_time) ${site} Wordfence-CLI vulnerability Scan ${c_light_blue}[${c_light_red}FAILED${c_light_blue}]${c_reset}"
    echo "$(midgard_current_time) Wordfence-CLI vulnerability Scan [FAILED]" >> "$SITE_LOG_FILE"
    echo "WORDFENCE_DB=FAIL" >> "${SITE_REPORT_FILE}"
    return 1
  fi

  # run scan (CSV only, silence INFO)
  local scan_csv
  scan_csv="$(mktemp)"

  set -o pipefail
  "$WORDFENCE_BIN" vuln-scan \
      --no-banner \
      --no-color \
      --no-verbose \
      --quiet \
      --accept-terms \
      --output-format=csv \
      --allow-io-errors \
      "$LOCAL_WP_ROOT" \
  | tee -a "$SITE_LOG_FILE" >"$scan_csv"
  rc1=$?
  set +o pipefail

  if (( rc1 != 0 )); then
    echo -e "$(midgard_current_time) ${site} Wordfence-CLI vulnerability Scan ${c_light_blue}[${c_light_red}FAILED (rc=$rc1)${c_light_blue}]${c_reset}"
    echo "$(midgard_current_time) Wordfence-CLI vulnerability Scan [FAILED rc=$rc1]" >> "$SITE_LOG_FILE"
    echo "WORDFENCE_VULN=FAIL" >> "$SITE_REPORT_FILE"
    rm -f "$scan_csv"
    return 1
  fi

  # Parse CSV safely with gawk (handles quoted fields and commas)
  # Title is the 5th column. We only accept rows where col1 is plugin/theme/core.
  mapfile -t vuln_titles < <(
    gawk -v FPAT='([^,]*)|("([^"]|"")*")' -F',' '
      ($1=="plugin" || $1=="theme" || $1=="core") {
        t=$5
        # strip surrounding quotes if present
        sub(/^"/,"",t); sub(/"$/,"",t)
        # unescape double-quotes inside quoted fields
        gsub(/""/,"\"",t)
        print t
      }
    ' "$scan_csv"
  )

  rm -f "$scan_csv"

  if ((${#vuln_titles[@]} > 0)); then
    for t in "${vuln_titles[@]}"; do
      echo -e "$(midgard_current_time) ${site}   Vulnerability found : ${c_light_red}$t${c_reset}"
      echo "$(midgard_current_time)   Vulnerability found : $t" >> "$SITE_LOG_FILE"
    done
    echo "WORDFENCE_VULN=FAIL" >> "$SITE_REPORT_FILE"
    echo -e "$(midgard_current_time) ${site} Wordfence-CLI vulnerability Scan ${c_light_blue}[${c_light_red}FAILED${c_light_blue}]${c_reset}"
    echo "$(midgard_current_time)  Wordfence-CLI vulnerability Scan [FAILED]" >> "$SITE_LOG_FILE"
    return 1
  else
    echo -e "$(midgard_current_time) ${site} Wordfence-CLI vulnerability Scan ${c_light_blue}[${c_green}SUCCESS${c_light_blue}]${c_reset}"
    echo "$(midgard_current_time) Wordfence-CLI vulnerability Scan [SUCCESS]" >> "$SITE_LOG_FILE"
    echo "WORDFENCE_VULN=OK" >> "$SITE_REPORT_FILE"
    return 0
  fi

}













return

# Safety guard
if [[ "${MIDGARD_MAIN:-}" != "1" ]]; then
  echo "This script must be sourced from the midgard launcher." >&2
  return 1 2>/dev/null || exit 1
fi

# name-ref getter: _get <assoc_array_name> <key>
_get() {
  local __arr="$1" __key="$2"
  declare -n __ref="$__arr"
  printf '%s' "${__ref[$__key]-}"
}

scan_wordfence_vuln_site() {
  local site="${1:-}"
  [[ -n "$site" ]] || { echo "scan_wordfence_vuln_site: missing site"; return 1; }

  local arr="${CONFIG_SITES[$site]:-}"
  [[ -n "$arr" ]] || { echo "scan_wordfence_vuln_site: site not loaded: $site"; return 1; }

  # Pull vars from loaded site map
  local LOCAL_SYNC_PATH LOCAL_DOCUMENT_ROOT WORDFENCE_BIN WORDFENCE_VULN_ENABLE
  LOCAL_SYNC_PATH="$(_get "$arr" LOCAL_SYNC_PATH)"
  LOCAL_DOCUMENT_ROOT="$(_get "$arr" LOCAL_DOCUMENT_ROOT)"
  WORDFENCE_BIN="${WORDFENCE_BIN:-$HOME/.local/bin/wordfence}"   # fallback if not set in global config
  WORDFENCE_VULN_ENABLE="$(_get "$arr" WORDFENCE_VULN_ENABLE)"

  # Paths for logs/reports
  local log_dir="logs/${EPOCH_TIMESTAMP}"
  local rep_dir="reports/${EPOCH_TIMESTAMP}"
  local site_log="${log_dir}/${site}.log"
  local site_rep="${rep_dir}/${site}.report"
  mkdir -p "$log_dir" "$rep_dir"

  # Respect per-site toggle
  if [[ "${WORDFENCE_VULN_ENABLE}" != "y" ]]; then
    echo "  wordfence vuln-scan ${site} ... [SKIPPED]" | tee -a "$site_log"
    echo "WORDFENCE_VULN=SKIPPED" >> "$site_rep"
    return 0
  fi

  # Validate binary
  if [[ ! -x "$WORDFENCE_BIN" ]]; then
    status_start "  wordfence vuln-scan ${site} ..."
    status_fail
    echo "    - Wordfence CLI not executable: ${WORDFENCE_BIN}" | tee -a "$site_log"
    echo "WORDFENCE_VULN=FAIL" >> "$site_rep"
    return 1
  fi

  # Determine WordPress root
  local wp_root="${LOCAL_SYNC_PATH%/}${LOCAL_DOCUMENT_ROOT}"
  if [[ ! -d "$wp_root" ]]; then
    status_start "  wordfence vuln-scan ${site} (missing ${wp_root}) ..."
    status_fail
    echo "    - WordPress root not found: ${wp_root}" | tee -a "$site_log"
    echo "WORDFENCE_VULN=FAIL" >> "$site_rep"
    return 1
  fi

  status_start "  wordfence vuln-scan ${site} ..."

  # Use line-delimited IDs for a clean count; still capture human output to log.
  # We run the scanner once with human output (for the log), then a second time
  # with line-delimited IDs to count findings. This avoids brittle greps.
  local tmp_human tmp_ids rc1=0 rc2=0
  tmp_human="$(mktemp -t wf-vuln-human.${site}.XXXXXX)"
  tmp_ids="$(mktemp -t wf-vuln-ids.${site}.XXXXXX)"

  # 1) Human-readable run (for operator log)
  if ! "$WORDFENCE_BIN" vuln-scan \
        --no-banner --no-color --no-verbose --accept-terms \
        --allow-io-errors \
        "$wp_root" >"$tmp_human" 2>&1; then
    rc1=$?
  fi
  cat "$tmp_human" >>"$site_log"

  # 2) Machine-friendly run to count exactly how many vulns were found
  #    If this fails, we still fall back to human run result.
  if ! "$WORDFENCE_BIN" vuln-scan \
        --no-banner --no-color --no-verbose --accept-terms \
        --allow-io-errors \
        --no-cache \
        --output-format line-delimited \
        --output-columns id \
        "$wp_root" >"$tmp_ids" 2>/dev/null; then
    rc2=$?
  fi

  # Count vulnerability records (each line is an ID)
  local vuln_count
  if [[ "$rc2" -eq 0 ]]; then
    # Trim blank lines just in case
    vuln_count="$(grep -cve '^[[:space:]]*$' "$tmp_ids" || true)"
  else
    # If the machine-friendly run failed, try a light heuristic on the human log
    # (look for lines that look like a result block)
    vuln_count="$(grep -Eic 'CVE-|Vulnerability|WordPress core vulnerability|plugin.*vulnerab|theme.*vulnerab' "$tmp_human" || true)"
  fi

  rm -f "$tmp_human" "$tmp_ids"

  # Decide final status
  # - If either run exited with a hard error (non-zero) AND we didn’t get a count, mark FAIL
  # - If vuln_count > 0 => FAIL (we want human intervention)
  # - Else OK
  if { [[ "$rc1" -ne 0 ]] && [[ "$rc2" -ne 0 ]]; } && [[ -z "${vuln_count:-}" ]]; then
    status_fail
    echo "    - wordfence vuln-scan errored (rc1=$rc1 rc2=$rc2) and no results to parse" | tee -a "$site_log"
    echo "WORDFENCE_VULN=FAIL" >> "$site_rep"
    return 1
  fi

  if [[ "${vuln_count:-0}" -gt 0 ]]; then
    status_fail
    echo "    - vulnerabilities detected: ${vuln_count} (see log for details)" | tee -a "$site_log"
    echo "WORDFENCE_VULN=FAIL" >> "$site_rep"
    return 1
  fi

  status_ok
  echo "WORDFENCE_VULN=OK" >> "$site_rep"
  return 0
}
